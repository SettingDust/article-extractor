import { extract } from './index'
import { expect } from 'chai'
import { readFileSync } from 'node:fs'
import { DOMParser } from 'linkedom'

describe('article-extractor', () => {
  it('should parse meta test', async () => {
    expect(
      await extract(readFileSync('./test/meta-test.html', { encoding: 'utf8' }))
    ).deep.equals({
      title: 'jsonld',
      author: { name: 'jsonld', url: 'https://jsonld.com' },
      url: 'https://jsonld.com',
      content:
        '<div><h2>class-title</h2><h2><a href="https://a-title.com/">a-title</a></h2><h3><a href="https://entry-title.com/">entry-title</a></h3><h3><a href="https://post-title.com/">post-title</a></h3> <a href="https://itemprop.com/">itemprop</a> <a href="https://rel2.com/">rel2</a> <a href="https://aclass.com/">a class</a> <a href="https://href.com/author/">href</a><h5><a href="https://classa.com/">class a</a></h5><h5>class</h5><h5> <span>itemprop name</span> <a href="https://itemprop-url.com/"></a>\r\n</h5></div>'
    })
  })
  it('should parse medium article', async () => {
    expect(
      await extract(
        <Document>(<unknown>new DOMParser().parseFromString(
          readFileSync(
            './test/An overview of web page content extraction.html',
            {
              encoding: 'utf8'
            }
          ),
          'text/html'
        )),
        {
          url: 'https://joyboseroy.medium.com/an-overview-of-web-page-content-extraction-5e0e2c62855d'
        }
      )
    ).deep.equals({
      author: {
        name: 'Joy Bose',
        url: 'https://joyboseroy.medium.com'
      },
      date: {
        modified: new Date('2021-12-14T22:02:20.308Z'),
        published: new Date('2020-06-14T20:03:29.001Z')
      },
      title: 'An overview of web page content extraction - Joy Bose',
      url: 'https://joyboseroy.medium.com/an-overview-of-web-page-content-extraction-5e0e2c62855d',
      content:
        '<div><div><article><div><p> In this article, we study the area of webpage content extraction, an area which has many useful applications. We also study a few popular algorithms for extraction.</p><p> <strong>Introduction</strong></p><p> Webpage content extraction refers to the process of extracting relevant content from a webpage and leaving out the irrelevant (noisy) content such as ads, table of contents, header and footer etc. It is also called by other names such as boilerplate removal.</p>\r\n<figure><figcaption>Reader Mode in a web browser </figcaption></figure><p> Some applications of webpage content extraction can be</p><ol><li> translation of the webpage content to a different language </li><li> reading the webpage content (a voice reader) </li><li> summarising the content </li><li> presenting the content in a readable form (reader mode in web browsers). </li></ol><p> From a high level, this is a classification problem, the objective being to label each HTML element in the\r\nwebpage, including text, images, multimedia and dynamic content, as relevant or noise. The more general version of this problem statement is to label the structure of the webpage, i.e. which part is the heading, which is the table of contents, which is the main body, which is a relevant image, which is the footer etc.</p><p> However, there are problems when developing an approach to solve the problem. The web is huge, having lots of unstructured data in image and different formats. So to develop\r\nan algorithm that will work for all kinds of websites is understandably hard. HTML, the language in which webpages are written, is not a very structured language and is perhaps a little too flexible. The layout of the webpage, how it appears visually, does not have any necessary correspondence with how the HTML is written. For example, what looks like an HTML table can merely be a formatting mechanism for different div elements and vice versa. This increases the difficulty of developing a\r\nsolution to this problem.</p><p> Various approaches have been proposed to solve this problem. Below we examine each of the algorithms and approaches in brief.</p><p> <strong>Extraction of webpage content based on Semantic Web</strong></p><p> The Semantic web was proposed in 2000s as an improved version of world wide web. The goal was to create a framework where web content was easy to understand. It used languages such as OWL (web ontology language). If a webpage uses this, then extraction\r\nbecomes trivial since the content is already tagged semantically.</p><p> <strong>Extraction of web content based on webpage templates</strong></p><p> This approach can be used in some cases where the webpages follow a common and generally known template. For example, wikipedia articles. Then it is relatively easy to train a model to recognise the template.</p><p> <strong>Extraction of content based on heuristic rules</strong></p><p> This method involves writing rules (such as based on regular\r\nexpressions). This may work with some simpler format or older HTML pages, but not for newer HTML pages or those having dynamically changing content.</p><p> Some example heuristic rules could be made using the following observations:</p><ul><li> Normally, content blocks (HTML block which is labeled as relevant content) are clustered together in webpage, so are noisy blocks. So if a content block is identified, its neighbours also likely to be content and vice versa </li><li> Noisy blocks (such as\r\nads) have more HTML tags and less text </li><li> Content blocks have more and longer text </li></ul><p> So we can define parameters such as</p><ul><li> Text density (text words per line in the HTML block) </li><li> Link density (HTML links per line in the HTML block) </li></ul><p> and make some rules using such parameters. The exact rules may be based on experimentation on a dataset of webpages.</p><p> Important algorithms using this technique are BTE and maximum subsequence segmentation (MSS)\r\nalgorithm.</p><ul><li> Body text extraction (BTE) algorithm (original, Finn 2001): Identify single continuous region with most text and least tags <a href="https://www.aidanf.net/posts/bte-body-text-extraction" target="_blank">https://www.aidanf.net/posts/bte-body-text-extraction</a></li><li> Max Subsequence Segmentation (MSS): <a href="http://ra.ethz.ch/CDstore/www2009/proc/docs/p971.pdf" target="_blank">WWW 09 paper</a> by Pasternack. In this approach, we think of webpage as a series of\r\ntokens. This reduces the problem of webpage content extraction to maximum subsequence (finding the maximum substring). To decide if the webpage contains an article, we identify a contiguous block of HTML, remove noise from the identified block <a href="http://cogcomp.org/papers/PasternackRo09.pdf" target="_blank">http://cogcomp.org/papers/PasternackRo09.pdf</a></li></ul><p> <strong>Arc90 Readability service</strong></p><p> This algorithm, called Arc90 Readability, was one of the earliest\r\nalgorithms used in web browsers. It was first used in Mozilla Firefox and in Apple Safari (modified). It was Heuristic based, had a number of heuristic rules. The steps included:</p><ul><li> Remove script tags, css etc from webpage </li><li> Traverse DOM tree of the webpage, assign score for each node as per rules, and bubble the score for the node parents, build a new DOM tree </li><li> Examine tags in webpage to assign score: H1 to H6, DIV, P, A, UL, OL, SCRIPT, INPUT, FORM, PRE, BLOCKQUOTE,\r\nDIV </li><li> <strong>Positive score</strong>: Body, content, article, column, entry, hentry, main, page, pagination, text, post, blog </li><li> <strong>Negative score (eliminate)</strong>: hidden, banner, footer, masthead, footnote </li><li> Get &lt;p&gt; paragraphs, add parents of each to list, initialize 0 score of parents, add or subtract points, find and render parent with most points </li></ul><p> References:</p><ul><li><a\r\nhref="https://github.com/mozilla/readability" target="_blank">https://github.com/mozilla/readability</a></li><li><a href="https://tuhrig.de/extracting-meaningful-content-from-raw-html/" target="_blank">https://tuhrig.de/extracting-meaningful-content-from-raw-html/</a></li><li><a href="http://blog.manbolo.com/2013/03/18/safari-reader-source-code" target="_blank">http://blog.manbolo.com/2013/03/18/safari-reader-source-code</a></li></ul><p> <strong>JusText algorithm</strong></p><p> This algorithm\r\nwas based on PhD thesis by Jan Pomikálek. It segments webpage using grammatical and other rules. The idea is that relevant (not ads) content is more likely to be grammatically correct, and vice versa. Noisy content, on the other hand, is more likely to have lists, enumerations etc function words. This algorithm uses stop words etc to determine if it is content text or not.</p><p> References:</p><ul><li><a\r\nhref="http://corpus.tools/wiki/Justext/Algorithm" target="_blank">http://corpus.tools/wiki/Justext/Algorithm</a></li><li><a href="https://is.muni.cz/th/o6om2/phdthesis.pdf?so=nx" target="_blank">https://is.muni.cz/th/o6om2/phdthesis.pdf?so=nx</a></li></ul><figure><figcaption>Illustration of the labeling of HTML snippets in a webpage using JusText algorithm </figcaption></figure><p> <strong>Machine learning techniques to extract content</strong></p><p> This involves using natural language\r\nprocessing (NLP) techniques such as web scraping and POS tagging to create a labelled dataset of webpage content. For example, we can label a particular HTML snippet as representing an image, another for heading, another for table of contents etc. Once the dataset is created, we train a machine learning model (such as support vector machine, decision trees, conditional random fields, or deep neural network) on the dataset. This is used to predict the labels for a new HTML page.</p><p> Some\r\npapers and PhD thesis using machine learning techniques are:</p><ol><li> Pomikálek, J., 2011. <em>Removing boilerplate and duplicate content from web corpora</em>. Doctoral dissertation, Masarykova univerzita, Fakulta informatiky. </li><li> Vogels, T., Ganea, O.E. and Eickhoff, C., 2018. Web2Text: <em>Deep Structured Boilerplate Removal.</em> arXiv preprint arXiv:1801.02607. </li></ol><p> <strong>Boilerpipe algorithm</strong></p><p> The Boilerpipe algorithm, or variants of it, are used in\r\nChromium based browsers such as Google Chrome. The feature in Chrome is called DOM Distiller. It is based on 2010 paper (boilerplate detection using shallow text features) and PhD thesis by Kohlschutter.</p><p> In this algorithm the features used: for current, previous, next blocks of HTML are as follows:</p><ul><li> Word Count (Number of words in current HTML block) </li><li> Average word length (number of chars) </li><li> Average sentence length (full stops, separators ?!.:) </li><li> Link\r\ndensity (number of links in block) </li><li> Text density (Words per line after word wrapping@80 chars per line) </li><li> Start uppercase ratio (how many words start with uppercase) </li><li> Densitometric features (Block fusion: fuse text fragments of similar text density) </li></ul><figure></figure><p> References</p><ol><li><a href="https://github.com/kohlschutter/boilerpipe" target="_blank">https://github.com/kohlschutter/boilerpipe</a></li><li><a\r\nhref="http://www.l3s.de/~kohlschuetter/boilerplate/" target="_blank">http://www.l3s.de/~kohlschuetter/boilerplate/</a></li><li><a href="http://boilerpipe-web.appspot.com/" target="_blank">http://boilerpipe-web.appspot.com/</a></li><li> Kohlschütter C, Fankhauser P, Nejdl W. 2010. Boilerplate detection using shallow text features. In <em>Proceedings of the third ACM international conference on Web search and data mining </em>WSDM ’10, ACM. </li></ol><p> <strong>Content Extraction based on Tag\r\nRations (CETR) algorithm</strong></p><p> The CETR was described in a paper published in WWW 2010 conference (content extraction via tag ratios). In this approach, we plot the tag ratio histogram (tag chars per line). After that, we apply a Gaussian Smoothing pass to give a Smoothed histogram. Finally we apply K Means clustering to find content/noise.</p><p> References</p><ul><li><a href="https://www3.nd.edu/~tweninge/cetr/" target="_blank">https://www3.nd.edu/~tweninge/cetr/</a></li><li> Similar\r\napproach: content code blurring (Gottron,2008) </li></ul><p> <strong>Webpage extraction using Conditional Random Fields</strong></p><p> This approach was described in a 2007 paper by Michal Marek, Powel Pecina. Here the problem is visualized as a sequence labelling problem. Their approach won the CleanEval 2007 competition.</p><p> The steps include the following :</p><ul><li> Preprocessing: clean page, tidy, remove &lt;scripts, style, embedded&gt; </li><li> Divide page into content blocks </li>\r\n<li> Manually label: content block as header, para, list, continuation, noisy blocks </li><li> Generate a feature vector for each block and run learning algorithm </li><li> Features: markup based (container.p, container.a, split.br), content based (char.alpha-rel, token.num-abs, sentence.avg-length), document related (position, document.word-count) </li></ul><p> Reference:\r\n<a href="https://ufal.mff.cuni.cz/~pecina/files/cleaneval-2007.pdf" target="_blank">https://ufal.mff.cuni.cz/~pecina/files/cleaneval-2007.pdf</a></p><p> <strong>Computer Vision based techniques</strong></p><p> This approach takes the actual webpage layout into account. Considering that the input HTML alone does not cover the CSS and even the CSS + HTML cannot cover the actual layout (there are additional factors such as screen size, type of agent such as mobile phone or PC or tab). Here computer\r\nvision techniques are used to segment the webpage into regions and to train the model to label each region separately. To make our task easier, we can use some rules that are true for most webpages such as: Content blocks are usually around the center of the webpage, noisy blocks around sides</p><p> The idea behind using such techniques is this: humans can instantly tell what is content and what is noise, even if it is for a different language webpage. So this approach is more natural to how we\r\nidentify a webpage.</p><p> <strong>VIPS algorithm</strong></p><p> VIPS is one of the techniques that simulates the layout of the webpage, It was first proposed by researchers in Microsoft Research China in 2003. This approach builds a visual tree from the DOM, simulates how the webpage ‘looks’ and which elements are coherent.</p><p> Partitioning of the webpage using the VIPS algorithm is done as follows:</p><ul><li> Extract nodes from DOM tree, find the horizontal and vertical separators </li>\r\n<li> Identify the visual blocks (change of font, size, color foreground or background) from DOM of parent HTML </li><li> Assign a score to each block : Degree of coherence of the elements. Repeat previous steps until coherence &lt; threshold </li><li> Finally, construct the visual tree </li></ul><figure><figcaption>VIPS algorithm</figcaption></figure><p> References:</p><ol><li><a\r\nhref="http://www.cad.zju.edu.cn/home/dengcai/VIPS/VIPS.html" target="_blank">http://www.cad.zju.edu.cn/home/dengcai/VIPS/VIPS.html</a></li><li><a href="https://www.microsoft.com/en-us/research/publication/vips-a-vision-based-page-segmentation-algorithm/" target="_blank">https://www.microsoft.com/en-us/research/publication/vips-a-vision-based-page-segmentation-algorithm/</a></li><li><a href="https://github.com/tpopela/vips_java" target="_blank">https://github.com/tpopela/vips_java</a></li><li>\r\nCai, D., Yu, S., Wen, J. R., &amp; Ma, W. Y. 2003. VIPS: a vision-based page segmentation algorithm. Technical report MSR-TR-2003–79, Microsoft Research </li></ol><p> <strong>Diffbot</strong> (a pure computer vision based technique)</p><p> Diffbot is a paid web service for automatic extraction of web data using computer vision techniques. Their algorithm follows a two step approach:</p><ul><li> Render the web page fully, including images, CSS, Ajax (10x faster webkit) </li><li> Everything the\r\nuser + browser sees: Analyze its visual layout using CV (object detection), layout, position info + browser info </li><li> Using Machine Learning, get likelihood of component being part of title, author, text, image </li><li> Return as JSON response </li></ul><p> References:</p><ul><li><a href="https://www.youtube.com/watch?v=Vm5joQ_Y5ow" target="_blank">https://www.youtube.com/watch?v=Vm5joQ_Y5ow</a></li><li><a\r\nhref="http://www.diffbot.com/testdrive" target="_blank">www.diffbot.com/testdrive</a></li><li> Diffbot : a company with extraction APIs based on image techniques. <a href="https://www.diffbot.com/products/automatic/" target="_blank">https://www.diffbot.com/products/automatic/</a></li></ul><p> <strong>Datasets to measure the accuracy of the extraction algorithm</strong></p><ol><li> CleanEval:\r\n<a href="https://github.com/ppke-nlpg/CleanPortalEval" target="_blank">https://github.com/ppke-nlpg/CleanPortalEval</a> and <a href="https://cleaneval.sigwac.org.uk/devset.html" target="_blank">https://cleaneval.sigwac.org.uk/devset.html</a> Cleaneval is the standard dataset used for evaluating boilerplate removal in academia, industry. It was part of a competition in 2007, has 58 English HTML pages and 51 Chinese HTML, annotated by 23 students. It includes gold standard files: Plain text with\r\nsimple markup without noise (header, text, paragraphs). It also has a scoring script to measure the accuracy of any extraction algorithm. </li><li> Mozilla Readability test dataset: <a href="https://github.com/mozilla/readability" target="_blank">https://github.com/mozilla/readability</a></li><li> Dragnet dataset <a href="https://github.com/dragnet-org/dragnet" target="_blank">https://github.com/dragnet-org/dragnet</a> and\r\n<a href="https://github.com/seomoz/dragnet_data" target="_blank">https://github.com/seomoz/dragnet_data</a></li><li> Google news dataset L3S-GN1 (news articles crawled from Google news)<br/><a href="https://github.com/geodrome/page-signal" target="_blank">https://github.com/geodrome/page-signal</a></li></ol><p> <strong>Available Github projects of content extraction algorithms with code</strong></p><ol><li> Arc90 Readability\r\n<a href="https://github.com/masukomi/arc90-readability" target="_blank">https://github.com/masukomi/arc90-readability</a></li><li> Boilerpipe <a href="https://github.com/kohlschutter/boilerpipe" target="_blank">https://github.com/kohlschutter/boilerpipe</a></li><li> VIPS <a href="https://github.com/tpopela/vips_java" target="_blank">https://github.com/tpopela/vips_java</a></li><li> Goldminer <a href="https://github.com/endredy/GoldMiner" target="_blank">https://github.com/endredy/GoldMiner</a>\r\n</li><li> Mozilla readability <a href="https://github.com/mozilla/readability" target="_blank">https://github.com/mozilla/readability</a></li></ol></div></article></div></div>'
    })
  })
})
